[toc]

本文主要摘抄自：[JavaGuide](https://javaguide.cn/)

# 集合

## 集合基本概念

Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 `Collection` 接口，主要用于存放单一元素；另一个是 `Map` 接口，主要用于存放键值对。

对于 `Collection` 接口，下面又有三个主要的子接口：`List`、`Set` 和 `Queue`。

## Collection 基本数据结构

List 接口：

- `Arraylist`：`Object[]` 数组
- `Vector`：`Object[]` 数组
- `LinkedList`： 双向链表

Set 接口：

- `HashSet` (无序，唯一): 
	- 基于 `HashMap` 实现的，底层采用 `HashMap` 来保存元素
- `LinkedHashSet`: 
	- `LinkedHashSet` 是 `HashSet` 的子类，并且其内部是通过 `LinkedHashMap` 来实现的。
	- 有点类似于 `LinkedHashMap` 其内部是基于 `HashMap` 实现一样，不过还是有一点点区别的
- `TreeSet` (有序，唯一): 
	- 红黑树(自平衡的排序二叉树)

Queue 接口：

- `PriorityQueue`: `Object[]` 数组来实现二叉堆
- `ArrayQueue`: `Object[]` 数组 + 双指针

## 遍历 Collection 的迭代器

### Iterator 和 Iterable

`Iterator` 是一个接口，有 2 个抽象方法：

1. `hasNext()` 来判断是否还有数据可以访问

2. `next()` 用来访问集合的下一个数据

集合并不是直接实现 `Iterator` 接口，而是通过实现 `Iterable` 接口，来返回当前集合实现了 `Iterator` 接口的迭代器实例。

这是为了每次都能返回新的迭代器，遍历数据时互不影响：

- 如果没有返回新的迭代器，而是只有一个迭代器
- 那么遍历完 1 次数据后，第 2 次就没有数据可以遍历了，所以选择每次都返回一个新的迭代器。

### fail-fast 机制

fail-fast 机制：

- 为了保证在迭代时，不会出现集合突然被添加或删除元素

- 迭代器中会保存一个 int 数值 modCount，用来记录集合增删操作的次数

- 在迭代时，会对比 modCount 是否和当初的数值一致

- 如果不一致，就抛出 `ConcurrentModificationException`，也就是 fail-fast

因为 for-each 循环的底层就是迭代器，所以在 for-each 中直接对集合进行增删操作，也可能会抛出异常。

### CopyOnWrite

作用：CopyOnWriteList 可以在遍历数据的同时，对集合进行增删操作。

原理：

- 为了避免增删元素时，影响到迭代器，CopyOnWrite 集合在增删元素时，就不会在原数组上操作，
- 而是会新建一个数组，然后将原数组的元素挨个复制过去，再在新数组上增删元素，这样就不会影响之前的迭代器。
- 而且增删操作还加上了 `synchronized` 锁，所以是线程安全的。
- 不过，读取的操作是没有加锁的，这是为了提高性能。

优点：

- CopyOnWrite 只会复制数据的引用，不会复制数据本身。所以在获取迭代器，或者说获取数据时，速度很快。
- 而且增删操作上了锁，所以还适合并发场景。
- 保障了迭代器的独立性和隔离性（读写分离）

缺点：

- 因为每次增删操作，都会复制数据，所以集合在增删操作时，性能比较低。
- 而且占用内存大，容易触发 GC。
- 读操作没有上锁，所以数据可能不是最新的，数据可能出现不一致的问题

适用范围：适用于读多写少，且数据量不大的情况。比如，配置和商品类别这种变更很少的数据。

## Map

`HashMap`：

- 数组 + 链表，数组是 `HashMap` 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）
- HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，以此来判断该元素应该存放的位置
	- 如果当前位置存在元素的话，就判断两个元素之间的 hash 值和 key 是否相同
	- 如果相同的话，直接覆盖，不相同就通过拉链法解决冲突
	- JDK1.8 之后，如果链表长度大于阈值（默认为 8）时，会将链表转化为红黑树，以减少搜索时间。
- `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个

`LinkedHashMap`：

- 在 `HashMap` 的基础上，添加了双向链表
- `LinkedHashMap` 继承自 `HashMap`，所以它的底层仍然是基于拉链式散列结构，即由数组和链表或红黑树组成。
- 另外，`LinkedHashMap` 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。
- 同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。

`ConcurrentHashMap`：

- 底层采用 **分段的数组 + 链表** 实现
- 在 JDK1.7 的时候，`ConcurrentHashMap` 将数据分为不同的 `Segment`，每一把锁只锁 `Segment` 中数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率
- JDK1.8 的时候已经摒弃了 `Segment` 的概念
	- 直接用 `Node` 数组+链表/红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。
	- `synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

`Hashtable`： 

- 数组 + 链表组成的，数组是 `Hashtable` 的主体，链表则是主要为了解决哈希冲突而存在的。
- `Hashtable` 是线程安全的，因为 `Hashtable` 内部的方法基本都经过 `synchronized` 修饰。
- 但是它是全表锁，也就是把所有数据都锁了起来
- 不允许有 null 键和 null 值

`TreeMap`： 

- 红黑树（自平衡的排序二叉树）
- 相比于 `HashMap` 来说 `TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力

`HashSet` ：

- 底层就是基于 `HashMap` 实现的
- `HashSet` 会先计算对象的 `hashcode` 值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，
- 如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。
- 但是如果发现有相同 `hashcode` 值的对象，这时会调用 `equals()` 方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。

# Spring

## Spring 的优点

Spring 的优点：

* 解耦，简化开发。通过 Spring 提供的 IoC 容器，可以由 Spring 管理控制对象，避免程序过度耦合
* 不用再为了单例模式和读取配置等底层的需求编写代码，可以专注于上层的应用
* 支持 AOP，实现传统 OOP 所不能实现的功能
* 支持声明式事务。通过声明的方式灵活管理事务，提高开发效率和质量
* Spring 生态强大，方便集成各种优秀框架
* 便于学习 Java 源码

## Spring Boot 的自动装配

在 Spring Boot 中，我们直接引入一个 starter 和少量注解即可完成配置。

SpringBoot 的核心注解 `@SpringBootApplication` 是 `@SpringBootConfiguration`、`@EnableAutoConfiguration`、`@ComponentScan` 注解的组合：

- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制
- `@ComponentScan`： 扫描被`@Component` (`@Service`,`@Controller`)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。
- `@SpringBootConfiguration`：其实就是 `@Configuration` ，允许在上下文中注册额外的 bean 或导入其他配置类

`@EnableAutoConfiguration` 只是一个简单地注解，自动装配核心功能的实现实际是通过 `AutoConfigurationImportSelector` 类：

- `AutoConfigurationImportSelector` 类可以加载自动装配类
- `AutoConfigurationImportSelector` 类实现了 `ImportSelector`接口，也就实现了这个接口中的 `selectImports` 方法，该方法主要用于**获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中**。
- 它会获取需要自动装配的所有配置类，读取所有 starters 的 `META-INF/spring.factories`
- 不是所有的 spring.factories 中的配置都会被加载，因为有一个 `@ConditionalOnXXX` 的注解来确立生效条件

总结：Spring Boot 通过 `@EnableAutoConfiguration` 开启自动装配，通过 SpringFactoriesLoader 最终加载 `META-INF/spring.factories` 中的自动配置类实现自动装配，自动配置类其实就是通过 `@Conditional` 按需加载的配置类，想要其生效必须引入 `spring-boot-starter-xxx` 包实现起步依赖。

# MySQL 索引

## 为什么要用索引

索引是一种用于快速查询和检索数据的排好序的数据结构。

如果没有索引，读取数据库中的数据的时候，需要不断地将磁盘中的数据，读取到内存中进行查找操作，这会产生大量 IO 操作，效率很低。

- 操作系统读取数据，是按照“页（page）”为单位的，也就是 1 页、2 页这样读取。

如果有了索引，就能直接访问该行数据，效率很高。

## 索引的数据结构

常见的索引结构有: B 树， B+ 树和 Hash。

Hash，数组+链表，问题是不支持范围查找：

```
[0]->[][][][][]
[1]->[][][][][]
[2]->[][][][][]
[3]->[][][][][]
```

B 树：

```
		[2]
	/		\
[1]		[3]
```

B+ 树：

```
				[1,9]
				/		\
[1,2,3,4(*1)]<-->[(*2)9,10,11,12]

*1：留出一小块空间，存放右边叶子结点的磁盘文件地址
*2：留出一小块空间，存放左边叶子结点的磁盘文件地址
```

为什么不让树的高度为 1？

- 因为查找的时候，需要一层一层地将数据加载到内存中查找。
- 如果一次性全部数据加载到内存中的话就会出现问题。

## 索引的优缺点

**优点** ：

- 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性，方便添加行锁。

**缺点** ：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

但是，**使用索引一定能提高查询性能吗?**

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

## 聚集索引和非聚集索引

这两个是数据组织的一种方式，不是真正意义上的索引。

聚集索引：

- 索引结构和数据一起存放的索引。
- 主键索引属于聚集索引。所以建议 InnoDB 建立整型的自增主键。

非聚集索引：

- 索引文件和数据文件是分开存放的
- 非聚集索引需要“回表”，也就是查找一次索引，再回到表中读取数据，所以没那么快

## 索引类型

### 主键索引(Primary Key)

数据表的主键列使用的就是主键索引。

**有唯一标识，主键不可重复，只能有一个列作为主键**。

一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

### 二级索引(辅助索引 Secondary Key)

1. **唯一索引(Unique Index)** ：
	* 唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
	* 这里的 "唯一" 是单独这一列唯一，我们希望身份证号是"唯一"的，银行卡号也必须"唯一"的。但不是说，有了身份证号，就不能有银行卡。
2. **普通索引(Index)** ：
	* **普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
	* 默认的索引，使用 index 或 key 来设置
3. **前缀索引(Prefix)** ：
	* 前缀索引**只适用于字符串类型的数据**。
	* 前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
4. **全文索引(Full Text)** ：
	* 全文索引主要是**为了检索大文本数据中的关键字的信息**，是目前搜索引擎数据库使用的一种技术。
	* MySQL 5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。

## 索引原则

适合：

- 索引一般加在频繁用来查询的字段上
- 在字符串类型的字段上使用前缀索引代替普通索引
- 关联字段需要建立索引，比如：外键字段
- 排序字段 order by
- 分组字段 group by（分组也是建立在排序基础上）
- 统计字段 count()，max() 这些

不适合：

- 索引不是越多越好
- 不要对经常变动的数据加索引
- 小数据量的表不需要加索引
- 注意避免冗余索引
- where 条件中用不到的字段不要建立索引
- 重复度高的字段，不适合建立索引。比如：男女，真假

## 联合索引 与 最左前缀匹配原则

索引是一种排好序的数据结构。对于单值索引而已，值只有一个，所以容易排序。

>**联合索引**，也叫 **组合索引** 或 **复合索引**。是最常见的。

对于联合索引而言，遵从**最左前缀匹配原则**，也就是从左到右依次匹配索引的值。

假设索引是 `name, age, gender`，只有以 `name` 开头的语句才会走索引。也就是不能跳过最左的值。

**最左前缀匹配原则**的原理：

```
				[a,1]								[d,1]
	/				|			\				/			|			\
[a, 1]	[b,3]	[c,2]		[d,1]	[e,2]	[f,1]
```

如果不是按照从左到右（也就是上面的字母->数字）的顺序的话，假设先以数字 2 开头，那么就要把所有数据都遍历一遍，这样就不是“排好序”的数据结构了。

也就说，必须要**满足有序性**，所以一定要从左到右依次匹配，才能满足有序性。

## 使用短索引

可以截取有区分度的一部分作为索引。比如 "baidu.com/fjiefibfiebufbue"，只需要截取到 "baidu.com" 作为索引就可以了。

## 索引失效的条件

1. **索引不能为 null，有一定几率会失效**

因为无法比较值的大小。这也是为什么主键不能为 null 的原因。

使用 `is null` 的时候，优化器根据 null/not null 的数量占比来决定是否走索引，使用有一定几率索引失效

解决方案是给一个特殊的值，比如 age 为 -1 就是特殊的值，来替换 null。

---

2. **每次查询，都只用一个索引**

如果 where 子句已经使用了索引，那么 order by 的时候是不会使用索引的。

*尽量使用联合索引*：比如 a,b,c 都建立索引，那么只会 a 的索引生效。所以要将 abc 设置为联合索引。

---

3. **使用 or 的时候，如果 or 的两边是单列索引会走，如果是联合索引会失效。**

假设是 `select * from a where id = 1 or uid = 2;` ，那么如果 id 加了索引，而 uid 没有加索引，那么就会失效。

如果要让索引生效，就必须 id 和 uid 都加上单列索引（注意，不是联合索引）。

---

4. **参与了列计算的列，索引会失效**

列计算：加减乘除，日期的计算，日期的格式化等等

5. **不符合最左原则，索引会失效**

6. **like 查询以 % 开头，索引会失效**

7. **MySQL 如果认为全表扫描速度更快，就不会走索引**
7. 使用了 `select *`

# MySQL 事务

## MySQL 事务的 4 大特性

ACID：

- Atomicity 原子性：多个动作，要么一起成功，要么一起失败
- Consistency 一致性：当事务完成时，必须使所有数据都具有一致的状态，保证数据的完整性
- Isolation 隔离性：多个用户同时操作，要排除其他业务对当前业务的影响
- Durability 持久性：只要事务提交了，就会持久化到数据库，造成永久的影响

## MySQL 事务隔离级别

隔离所导致的问题：

- 脏读（Dirty read）：一个事务读取了另一个事务还未提交的数据
- 不可重复读（Unrepeatableread）：读取表中某行数据时，多次读取的结果不同（可能因为刚好数据更新了，所以不一定是错误）
- 幻读（虚读 Phantom read）：读取到了别的事务插入（或删除）的数据（第一次没读到，第二次发现读到了；或第一次读到，第二次又读不到）
- 丢失修改（Lost to modify）：
	- 在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
	- 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。


事务的隔离级别：

- Read Uncommitted：
	- 读未提交
	- 即使一个更新语句没有提交，但是别的事务可以读到这个改变。
	- 这是很不安全的。因为别人可能会 rollback（回滚）
	- 允许任务读取数据库中未提交的数据更改，也称为脏读。
	- 问题：脏读、不可重复读、幻读（虚读）
- Read Committed：
	- 读已提交
	- 可防止脏读。语句提交以后即执行了 COMMIT 以后别的事务就能读到这个改变. 只能读取到已经提交的数据。
	- 问题：不可重复读、幻读（虚读）
- Repeatable Read：
	- 可重复读
	- 同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。
	- 在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。
	- 问题：幻读（虚读）
- Serializable：
	- 串行化
	- 这个事务执行的时候不允许别的事务并发执行。
	- 完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

## MySQL表锁和行锁

- **表级锁：** 
	- MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁
	- 实现简单，资源消耗也比较少，加锁快，基本不会出现死锁。
	- 其锁定粒度最大，触发锁冲突的概率最高，并发度最低
	- MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** 
	- MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。
	- 行级锁能大大减少数据库操作的冲突。
	- 其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

## InnoDB 存储引擎的锁

Record Lock 记录锁

- 如果没有索引，就是表锁。
- 如果有索引，就是行锁。

Gap lock：间隙锁

- 当查询一个范围的时候，锁定一个范围
- 但是不包括记录本身

Next-key lock：临键锁 = 间隙锁 + 记录锁

- 锁定一个范围，包含记录本身
- 目的：避免幻读

MDL 锁：

- 上锁，防止有人修改表结构

## 解决死锁

- 尽量让数据表中的数据检索都通过索引来完成，避免无效索引导致行锁升级为表锁。
- 合理设计索引，尽量缩小锁的范围。
- 尽量减少查询条件的范围，尽量避免间隙锁或缩小间隙锁的范围。
- 尽量控制事务的大小，减少一次事务锁定的资源数量，缩短锁定资源的时间。
- 如果一条SQL语句涉及事务加锁操作，则尽量将其放在整个事务的最后执行。尽可能使用低级别的事务隔离机制。

## 乐观锁和悲观锁

悲观锁：手动上锁

乐观锁：加一个 version 字段，每次 update 的时候都带上 version 的判断条件。

# MySQL

## 数据库的列类型

char & varchar

- char 0-255 固定大小
- varchar 0-65535 可变字符串

时间日期：

- date：YYYY-MM-DD
- time：HH:mm:ss
- datetime：YYYY-MM-DD HH:mm:ss
- timestamp
- year

# SQL

## SQL 优化

> 使用 `explain` 分析 SQL 语句，主要查看 `rows`

总结到SQL优化中，就三点:

- 正确建立索引，最大化利用索引；
- 尽可能避免全表扫描；
- 减少无效数据的查询

具体而言：

- 避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描：
	- `SELECT * FROM t WHERE username LIKE '%陈%';` 中的 `'%陈%'` 替换为 `'陈%'`
	- 可以使用 FullText 全文索引，用 match against 检索
	- 如果数据量大，使用 Elasticsearch
	- 如果数据量小，直接 `% %` 也没什么关系
- 避免出现不确定结果的函数

- SELECT 语句指明字段名称，尽量不要使用 `*`
- 只查询一条数据的时候，使用 limit 1
- 避免出现不确定结果的函数（避免出现 now()、rand()、sysdate()、current_user() 等）
- 使用表的别名，减少解析时间
- 禁止使用不含字段列表的 INSERT 语句：
	- 不要使用：`insert into t values ('a','b','c');`
	- 而要使用：`insert into t(c1,c2,c3) values ('a','b','c');`
- 对应同一列进行 or 判断时，使用 in 代替 or：
	- in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。
- 避免使用 JOIN 关联太多的表
- 避免使用子查询，可以把子查询优化为 join 操作

# MyBatis

## MyBatis ${} 与#{} 拼接字符串区别

`#{}` 是编译好 SQL 语句，再取值的占位符号，是安全的：

```sql
# 这条 SQL
select * from emp where name = #{employeeName};
# 会被转换为：
select * from emp where name = 'Smith'; 
```

`${}` 是取值以后，再去编译SQL语句的拼接符号，是非安全的，存在 SQL 注入：

```sql
# 这条 SQL
select * from emp where name = ${employeeName};
# 会被转换为：
select * from emp where name = Smith
```

## like 拼接参数

1. `like '%${XX}%'`
2. `like "%"#{XX}"%"`
	- 因为 `#{...}` 解析成 sql 语句时候，会在变量外侧自动加单引号 `''`
	- 所以这里 `%` 需要使用双引号 `""`，不能使用单引号 `''`，不然会查不到任何结果
3. 使用 `CONCAT()` 函数连接参数形式
	- `like concat(concat("%",#{eventDto.eventContent}),"%")`
	- 建议使用这一种，函数连接字符串

# Redis

## Redis 的基本数据结构

Redis 的基本数据结构：

- String 字符串类型
- List 列表类型
- Set 集合类型
- Hash 哈希类型
- Zset 有序集合类型
- Geospatial 地理位置信息
- Hyperloglog 基数统计
- Bitmap 位图场景

## Redis 过期数据的删除策略

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。

### 惰性删除 / 被动删除策略

当读/写一个 key 时，如果发现它是过期的，就把它删除掉。

缺点是，有些过期的数据，只要没被读/写，就一直不会被删除。

### 定期删除 / 主动删除策略

每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

## Redis 淘汰策略

当内存的使用率达到 Max memory 的上限的时候，Redis 释放内存的一种行为。

### Redis 数据淘汰策略

> **volatile** 已经设置过期时间 key 集合。
>
> **allkeys** 所有 key 集合。

volatile-lru：

- least recently used
- 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

volatile-ttl：

- 从已设置过期时间的数据集中挑选将要过期的数据淘汰

volatile-random：

- 从已设置过期时间的数据集中任意选择数据淘汰

volatile-lfu：

- 4.0 版本后增加
- least frequently used
- 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰

allkeys-lru：

- least recently used
- 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）

allkeys-random：

- 从数据集中任意选择数据淘汰

allkeys-lfu：

- 4.0 版本后增加
- least frequently used
- 当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

no-eviction：

- 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错

## Redis 内存淘汰算法

Random 随机

- 随机淘汰某个 key

TTL 算法

- 在设置了过期时间的 key 里面，找到更快要过期的 key，进行有限移除

LRU 算法

- 移除最近很少使用的 key

- LRU 是常见的内存淘汰算法，Redis 里面维护一个大小为 16 的候选池，候选池里面的数据会根据时间进行排序
- 每次随机抽取 5 个 key，放到候选池里面。当候选池满了后，访问时间间隔最大的 key，就会从候选池里面淘汰掉。
- 通过这个设计，可以把真实的最少访问的 key，从内存中淘汰。
- 缺点：假如一个 key，长时间没被访问，但是最近一次偶然被访问到，就会被识别为热门 key，不会被淘汰

LFU 算法

- 为了解决 LRU 的问题，Redis 4 以后，增加了 LFU 算法。
- LFU 增加了访问频率的维度，来统计数据的热点情况。
- LFU 主要使用了 2 个双向链表。形成二维的双向链表。
- 一个用来保存访问的频率，另一个保存访问频率相同的 key。
- 当添加元素的时候，访问频率默认为 1。找到相同频率节点对应的双向链表的头部。
- 当元素被访问的时候，会增加 key 对应的访问频率，并且把当前访问的节点，移动到 +1 频率的节点。
- 如果单纯按照访问频率进行淘汰的话，假如一个 key 早期频繁被访问，后期没被访问，也很难被淘汰掉。
- 所以 LFU 通过使用频率和上次访问时间，来标记数据的热度。
- 缺点：LFU 需要维护访问频次，复杂度增高

# 多线程

## 线程的 6 种状态

使用 getState() 可以获取线程的 **6** 种状态

- NEW：新线程
- RUNNABLE：可运行状态
- BLOCKED：
	- 阻塞状态
	- 等待/拿到同步锁
- WAITING：
	- 等待状态
	- 等待其他线程的通知/收到通知，继续执行
- TIMED_WAITING：
	- 定时等待
	- 超时等待
- TERMINATED：终止状态

## 线程和进程?

- 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
- 线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。

## 调用线程的 4 种方式

1. 继承 Thread 类，重写 run 方法
2. 实现 Runnable 接口创建任务，并交由 Thread 执行执行该任务
3. 实现 Callable 接口，并配合 FutureTask 实现线程的阻塞调用，并将结果返回。
4. 利用线程池调用线程

## 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

调用 `start()` 方法方可启动线程并使线程进入就绪状态，而 `run()` 方法只是 thread 的一个普通方法调用，还是在主线程里执行。

## 死锁

产生死锁的必要条件：

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
4. 环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链

预防死锁：

1. 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
3. 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
4. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

## synchronized 关键字的底层实现

> 可以联系 JVM 底层来回答。

- 进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器 −1
- 当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态

Synchronized 是在加锁，加对象锁。

对象锁是一种重量锁（Monitor），Synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 Synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等，该关键字是一个几种锁的封装。

## ThreadLocal（线程局部变量）关键字

当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，因此每一个线程都可以独立改变自己的副本，而不会影响其他线程对应的副本。

ThreadLocal 内部实现机制：

- 每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干的 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程。
- Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系。
- Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。

# 反射

## 反射作用

Java 为静态语言，通过反射使其具有动态性：

- 类在创建后，还可以动态改变一些类的数据
- 获取运行时，类的内部信息，可以直接操作类的内部属性和方法
- 最常用是反射获取注解
- 很多框架里面应用的动态代理，也是反射的功能
- Spring 框架中就是通过反射来创建对象，从而降低系统耦合度的

## 反射基础

优点：动态创建对象，很灵活
缺点：影响性能。反射是解释操作，告诉 JVM 要做什么

Class.forName:

- Class.forName("类名") 获取 Class，Class 包含类信息。每个 Class 在 JVM 中只有一个 Class 实例。Class 对象对应的是加载到 JVM 中的 class 文件
- newInstance() 方法，调用无参构造器，创建实例
- get interface, get class loader, get constructors, get methods, get declared fields
- 初始化的时候，JVM 使用 client 指令初始化（静态变量，静态代码块，代码块，构造方法），如果父类没有初始化，就先初始化父类。

## AOP 的底层实现原理

- JDK 的 java.lang.reflect 的 `InvocationHandler` 接口
- Cglib 的 Enhancer 继承原始类

## 创建代理的三要素

1. 原始对象
2. 额外功能
3. 让代理对象和原始对象实现相同的接口

**让代理对象和原始对象实现相同的接口**的原因：

1. 保证 *代理类* 和 *原始类* 方法一致，迷惑调用者
2. 代理类可以在执行原始方法的前后（包括抛出异常），添加额外的功能

# WebService

一个部署在Web服务器上，**向外界暴露出一个能够通过 Web 进行调用的 API**。

也就是说：当我们想要获取天气预报的信息，我们可以调用别人写好的service服务，我们调用就能够得到结果了

**WebService 实际上就是 http + XML**

# Java

## 多态、继承和封装 —— 面向对象的三大特征

多态：

- 定义：一个对象具有多种的状态，具体表现为 *父类的引用* 指向 *子类的实例*
- *对象类型* 和 *引用类型* 之间具有<u>继承（类）/实现（接口）</u>的关系
- *引用类型变量* 调用的到底是哪个类中的方法，必须在程序运行期间才能确定
- 多态不能调用“只在子类存在但在父类不存在”的方法
- 如果子类重写了父类的方法，执行的是子类覆盖的方法；如果子类没有覆盖父类的方法，执行的是父类的方法

继承：

- 继承是使用已存在的类的定义作为基础建立新类的技术。
- 新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。
- 特点：
  - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
  - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  - 子类可以用自己的方式实现父类的方法。


封装：

- 定义：把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。
- 就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。
- 如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

## 抽象类和接口

> 接口只有方法和静态常量。
>
> Java 8 后，接口可以用 default 关键字或 static，实现方法（有方法体）。
>
> Java 9 后，接口可以用 private 关键字实现方法（有方法体）

共同：

- 可以定义抽象方法
- 不能创建本类的实例对象，只能由子类去实例化子类对象

不同：

- 抽象程度
	- 接口比抽象类更抽象，因为它只有方法。子类实现接口后，只能重写方法
	- 而子类在继承抽象类后，还会把抽象类的成员属性也继承过来
- 子类要扩展时
	- 接口是实现，implements 关键字
		- 接口和接口之间支持多实现，一个类可以实现多个接口
	- 抽象类是继承，extends 关键字
		- 类和类之间只能单继承，一个类只能继承一个类
- 能力
	- 接口：主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。
	- 抽象类：主要用于代码复用，强调的是所属关系。
- 构造方法
	- 抽象类中有构造器，用于限定子类的构造行为
		- 抽象类不能被实例化，但它还是有构造器
		- 因为抽象类可以将构造器定义好几个参数，子类必须传入那几个参数
	- 接口没有构造器
- 成员属性（成员变量）
	- 接口不能定义成员属性，只能定义 `public static final` 的静态常量，不能定义静态变量
	- 抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值
- 使用场景
	- 当需要让子类继承成员变量，或者需要控制子类的实例化时，就用抽象类
	- 否则就用接口

## equals()、hashCode() 与 ==

> `hashCode()` 的默认行为是对堆上的对象产生独特值。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
>
> == 和 hashCode() 没有直接关系

**为什么重写 equals() 时必须重写 hashCode() 方法？**

`hashCode()` 和 `equals()` 都是用来判断对象是否相等的

-  `hashCode()` 是用来快速判断的（比如，在 Map 中定位索引位置），但可能出现误差。

- 当 hash 冲突时，我们就通过 `equals()` 方法，来判断冲突对象是否绝对相等。

- 也就是说，`hashCode()` 用来保证性能，`equals()` 用来保证可靠。

如果只重写了 `hashCode()`

- 当 hash 冲突时，即使两个对象相等，也不会被判定为重复，进而导致存储了一大堆重复的对象。

如果只重写了  `equals()` 

- 那么两个相等的对象，内存地址可能就会不相等，这样还是会造成重复元素的问题。

---

**`==` 与 `equals()` 的区别**

`==` 比较内存地址，`equals()` 比较值。

对于基本类型来说，`==` 比较的是值是否相等；

对于引用类型来说，`==` 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；

对于引用类型（包括包装类型）来说，`equals()` 如果没有被重写，对比它们的地址是否相等；如果 `equals()` 方法被重写（例如 String），则比较的是属性值。

## String、StringBuilder 和 StringBuffer

String：

- 只读字符串
- String 类是 final 类
	- 不可以被继承
	- String 引用的字符串内容是不能被改变的
- 每次对String的操作都会生成新的String对象

StringBuffer / StringBuilder类：

- 可变类
- 表示的字符串对象可以直接进行修改。
- StringBuffer 线程安全

## 基本类型和包装类型

- 默认值：包装类型不赋值就是 `null` ，而基本类型有默认值
- 泛型：包装类型可用于泛型，基本类型不可以
- 基本数据类型占用的空间非常小
- 存放位置：
  - <u>基本类型的局部变量</u>存放在 JVM Stack（Java 虚拟机栈）中的局部变量表中
  - <u>基本类型中，未被 `static` 修饰的成员变量</u>存放在 JVM Heap（Java 虚拟机的堆）中
  - <u>包装类型</u>属于对象类型，几乎所有对象实例都存在于 Heap（堆）中
  - 上面提到的 *几乎所有对象实例* ，是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

## 成员变量与局部变量

语法形式 ：

- <u>成员变量</u>属于类，<u>局部变量</u>是在代码块或方法中定义的变量或是方法的参数
- <u>成员变量</u>可以被 `public`, `private`, `static` 等修饰符所修饰，<u>局部变量</u>不能被访问控制修饰符及 `static` 所修饰
- 相同：成员变量和局部变量都能被 `final` 所修饰。

存储方式 ：

- 如果<u>成员变量</u>是使用 `static` 修饰的，那么这个成员变量是属于类的
- 如果<u>成员变量</u>没有使用 `static` 修饰，这个成员变量是属于实例的，存在于 Heap（栈）中
- <u>局部变量</u>存在于 Stack（栈内存）。

生存时间 ：

- <u>成员变量</u>是对象的一部分，它随着对象的创建而存在
- <u>局部变量</u>随着方法的调用而自动生成，随着方法的调用结束而消亡。

默认值 ：

- 正常情况下，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外：被 `final` 修饰的成员变量也必须显式地赋值）
- <u>局部变量</u>则不会自动赋值

## final, finally, finalize的区别

final, finally, finalize的区别：

* final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承
* finally 是异常处理语句结构的一部分，表示总是执行
* finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。



# 业务流程

> 数据库：JDBC 连接

> 前后端数据交互：RESTful API，映射实体类

业务流程：

1. 搜集需求
2. 筛选需求
3. 软件设计
4. 对应文档
5. 开发阶段：
	1. 交接需求
	2. 正常开发
	3. 测试
	4. 上线演练
	5. 上线
	6. 交付
	7. 验收
	8. 维护
