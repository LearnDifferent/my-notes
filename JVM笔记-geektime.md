# Java 虚拟机是怎么运行 Java 字节码的？

从虚拟机的视角，Java 代码首先会被编译为 class 文件，然后被加载到 Java 虚拟机中。加载后的 Java 类被存放于 **方法区/Method Area** 中。
- 在实际运行时，虚拟机会执行 **方法区/Method Area** 内的代码。

Java 虚拟机还会在内存中划分出 **堆/Heap** 和 **栈/stack** 来存储运行时数据。
- 栈/stack：被细分为 *面向 Java 方法的 Java 方法栈*、*面向本地方法/native 方法的本地方法栈* 和存放各个线程执行位置的 *程序计数器/PC寄存器/PC Register*。
- 在运行的过程中，每当调用进入一个 Java 方法，Java 虚拟机就会在当前线程的 *Java 方法栈* 中生成一个 *栈帧/Stack Frame*，用来存放局部变量和字节码的操作数。
    - 这个 *栈帧/Stack Frame* 的大小是提前计算好的，而且 Java 虚拟机不要求 *栈帧/Stack Frame* 在内存空间里连续分布
    - 当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机都会弹出当前线程的当前 *栈帧/Stack Frame*，并将之舍弃
    
硬件视角来看，Java 字节码无法直接执行，因此 Java 虚拟机需要将字节码翻译成机器码。在 HotSpot 中，翻译过程有两种形式：
1. 解释执行：
    - 将逐条字节码翻译成机器码
    - 无需等待编译
2. 即使编译/Just-In-Time compilation/JIT：
    - 将一个方法中包含的所有字节码编译成机器码后再执行
    - 实际运行速度更快

HotSpot 在翻译时默认采用混合模式，它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译：
- 我们假设程序符合二八定律，20% 的代码占据了 80% 的计算资源
- 对于不常用的代码，就不用花费时间编译成机器码，直接采用解释执行即可
- 对于小部分热点代码，将其编译成机器码就可以提高运行时的速度





