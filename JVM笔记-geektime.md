# Java 虚拟机是怎么运行 Java 字节码的？

为什么使用 JVM 来运行 Java 字节码？

- 可以轻松实现 Java 代码的跨平台执行
- JVM 提供了一个托管平台，提供内存管理、垃圾回收、编译时动态校验等功能
- 使用 JVM 能够让我们的编程工作更轻松、高效节省公司成本，提示社会化的整体快发效率，我们只关注和业务相关的程序逻辑的编写，其他业务无关但对于编程同样重要的事情交给 JVM 来处理

---

从虚拟机的视角，Java 代码首先会被编译为 class 文件，然后被加载到 Java 虚拟机中。加载后的 Java 类被存放于 **方法区（Method Area）** 中。

在实际运行时，虚拟机会执行  **方法区（Method Area）** 内的代码。

Java 虚拟机还会在内存中划分出 **堆（Heap）** 和 **栈（Stack）** 来存储运行时数据。

JVM 中的 Stack 可以细分为：

- 面向 Java 方法的 Java 方法栈
- 面向本地方法（native 方法）的本地方法栈
- 存放各个线程执行位置的程序计数器（PC寄存器/PC Register）

在运行的过程中，每当调用进入一个 Java 方法，Java 虚拟机就会在当前线程的 **Java 方法栈** 中生成一个 **栈帧（Stack Frame）** ，用来存放局部变量和字节码的操作数：

- 这个 *栈帧（Stack Frame）* 的大小是提前计算好的，而且 Java 虚拟机不要求 *栈帧（Stack Frame）* 在内存空间里连续分布
- 当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机都会弹出当前线程的当前 *栈帧（Stack Frame）*，并将之舍弃

硬件视角来看，Java 字节码无法直接执行，因此 Java 虚拟机需要将字节码翻译成机器码。在 HotSpot 中，翻译过程有两种形式：
1. 解释执行：
    - 将逐条字节码翻译成机器码
    - 无需等待编译
2. 即使编译/Just-In-Time compilation/JIT：
    - 将一个方法中包含的所有字节码编译成机器码后再执行
    - 实际运行速度更快

HotSpot 在翻译时默认采用混合模式，它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译：
- 我们假设程序符合二八定律，20% 的代码占据了 80% 的计算资源
- 对于不常用的代码，就不用花费时间编译成机器码，直接采用解释执行即可
- 对于小部分热点代码，将其编译成机器码就可以提高运行时的速度

# Java 的基本类型

## JVM 中的 boolean 类型

boolean 类型在 Java 虚拟机中被映射为整数类型（int）： **`true` 被映射为 1，而 `false` 被映射为 0**

**Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的**

## Java 的基本类型

除 boolean 类型之外，Java 还有另外 7 个基本类型：

- 整数类型 byte、short、char、int 和 long
- 浮点类型 float 和 double

它们拥有不同的值域，大的值域会包含小的值域，所以值域小的基本类型不需要强制转换就能转为值域大的基本类型。

需要注意：

- **所有基本类型的默认值在内存中均为 0**
- 无符号的类型只有 boolean 和 char
	- char 的取值范围则是 [0, 65535]
		- 正常情况 char 类型的值为非负数
		- 这种特性十分有用，比如说作为数组索引等
	- boolean 的取值是 0 或 1
- 浮点类型（float）在运算或比较时，需要考虑 +0.0F、-0.0F 以及 NaN 的情况：在向量化比较的时候需要考虑这个特性

## Java 基本类型的大小

Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。

> 这里只讨论供解释器使用的解释栈帧（interpreted frame）

栈帧有两个主要的组成部分：

- （广义的）局部变量区
	- 局部变量
	- 实例方法的 `this` 指针
	- 方法所接收的参数
- 字节码的操作数栈

在 Java 虚拟机规范中，**局部变量区等价于一个数组，并且可以用正整数来索引** ：

- 除了 long、double 需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元
	- boolean、byte、char、short、int 及引用类型，在解释执行的方法栈帧中占用的空间大小是一致的
	- 在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节
- 这种情况仅存在于局部变量，而不会出现在存储于堆中的字段或者数组元素上
	- byte、char 以及 short 这三种类型的字段或者数组单元在堆上占用的空间分别为一字节、两字节，以及两字节
	- 也就是说，跟这些类型的值域相吻合
	- 因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作
	- boolean 字段和 boolean 数组比较特殊：
		- 在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现
		- 为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作
		- 也就是说，只取最后一位的值存入 boolean 字段或数组中
- 产生区别的主要原因：变长数组在堆中不好控制，所以就选择浪费一些空间，以便访问时直接通过下标来计算地址

总结一下，就是 **虽然除了 long 和 double 外，其他基本类型与引用类型在栈上占用的空间大小一致，但它们在堆中占用的大小却不同**

> 在内存中，数据类型是不做区分的。Java程序想要把它解读成什么类型，它就是什么类型。

承上启下：

- 在将 boolean、byte、char 以及 short 的值存入字段或者数组单时，Java 虚拟机会进行掩码操作
- 在读取（加载）时，Java 虚拟机则会将其扩展为 int 类型

加载：Java 虚拟机的算数运算几乎全部依赖于操作数栈， **我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算**

- 对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。
- 对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。

